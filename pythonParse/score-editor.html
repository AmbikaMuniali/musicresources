<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√âditeur de Partitions Tonic Solfa</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .note {
            cursor: pointer;
            position: relative;
        }
        .note-content, .symbol-content {
            border: 1px solid #e2e8f0;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: #f8fafc;
            transition: background-color 0.2s;
            display: block;
            width: 100%;
        }
        .note:hover .note-content {
            background-color: #e0f2fe;
        }
        .score-table {
            border-collapse: collapse;
            border-left: 2px solid black;
            margin-right: 8px;
        }
        .score-table td {
            padding: 2px 4px;
            vertical-align: middle;
            text-align: center;
        }
        .beat.selected {
            background-color: #dbeafe;
        }
        .voice-name {
            font-weight: bold;
            width: 110px;
            text-align: right;
            padding-right: 10px;
            cursor: pointer;
            vertical-align: top;
        }
        .lyrics-input {
            width: 50px;
            min-width: 45px;
            border: 1px solid #ccc;
            padding: 2px;
            font-family: monospace;
            text-align: center;
        }
        .beat-control-button {
            padding: 2px 4px;
            font-size: 0.75rem;
            margin: 0 1px;
            border-radius: 4px;
            color: white;
        }
        .beat-duration {
            font-size: 0.75rem;
            color: #4a5568;
            margin-top: 2px;
        }
        .lyric-voice-editor {
            font-size: 0.8rem;
            text-align: left;
        }
        .lyric-voice-editor label {
            margin-left: 4px;
            font-weight: normal;
        }
        .system-group {
            display: flex;
            align-items: center;
            margin-right: 1.5rem;
        }
        .system-brace {
            font-family: monospace;
            font-size: 8rem;
            line-height: 1;
            align-self: flex-start;
            margin-top: 1.5rem;
            margin-right: 0.5rem;
            padding-right: 0.5rem;
        }
    </style>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>
<body class="bg-gray-100 text-gray-800 p-4 sm:p-6 md:p-8">

    <div id="app" class="max-w-full mx-auto bg-white p-6 rounded-lg shadow-lg">
        <!-- Ent√™te -->
        <header class="mb-6 border-b pb-4">
            <div class="grid grid-cols-3 items-center text-center">
                <div class="text-left">
                    <input type="text" v-model="score.meta.scoreNumber" class="text-lg font-bold w-24 p-1 border rounded">
                </div>
                <h1 class="text-3xl font-bold">
                    <input type="text" v-model="score.meta.title" class="w-full text-center p-1 border rounded">
                </h1>
                <div class="text-right font-bold">
                    Tonalit√©:
                    <select v-model="score.meta.key" class="w-24 p-1 border rounded">
                        <option v-for="(name, key) in tonalKeys" :value="key">{{ name }}</option>
                    </select>
                </div>
            </div>
            <div class="grid grid-cols-3 items-center text-center mt-2">
                <div class="text-left">
                    <input type="text" v-model="score.meta.authors" class="w-full p-1 border rounded">
                </div>
                <div class="italic">
                    <input type="text" v-model="score.meta.subtitle" class="w-full text-center p-1 border rounded">
                </div>
                <div class="text-right">
                    <input type="text" v-model="score.meta.referenceBook" class="w-full text-right p-1 border rounded">
                </div>
            </div>
            <div class="flex items-end mt-4">
                <div class="mr-6">
                    <label for="time-signature" class="font-bold block">Mesure:</label>
                    <select id="time-signature" v-model="score.meta.timeSignature" class="p-1 border rounded">
                        <option>2/4</option> <option>3/4</option> <option>4/4</option> <option>6/8</option>
                    </select>
                    <div class="text-sm">
                        Tempo: <input type="number" v-model.number="score.meta.tempo" class="w-16 p-1 border rounded"> bpm
                    </div>
                </div>
            </div>
        </header>

        <!-- Partition -->
        <main>
            <div class="flex items-center mb-4">
                <h2 class="text-2xl font-semibold mr-4">Partition</h2>
                <button @click="addVoice()" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded mr-2 text-sm">+ Ajouter Voix</button>
                <button @click="addLyricLine" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded mr-2 text-sm">+ Ajouter Ligne Paroles</button>
                <button @click="exportToJson" class="bg-indigo-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded text-sm">Exporter en JSON</button>
            </div>

            <!-- Full Score -->
            <div class="flex flex-wrap pb-4">
                <template v-for="(measures, systemIndex) in systems" :key="systemIndex">
                    <div class="system-group">
                        <span class="system-brace">{</span>
                        <div class="flex">
                            <table v-for="(measure, measureIndex) in measures" class="score-table">
                                <!-- Symboles -->
                                <tr>
                                    <td v-if="systemIndex === 0 && measureIndex === 0" class="voice-name text-sm">Symboles</td>
                                    <td v-for="(beat, beatIndex) in score.voices[0].measures[measure.originalIndex].beats" :key="beatIndex">
                                        <input type="text" v-model="beat.symbol" class="symbol-content w-full text-center" placeholder="p, f, ùÑê...">
                                    </td>
                                </tr>
                                <!-- Voix -->
                                <tr v-for="(voice, voiceIndex) in score.voices" :key="voice.id">
                                    <td v-if="systemIndex === 0 && measureIndex === 0" class="voice-name" @click="editing.instrumentForVoice = voice.id">
                                        <span v-if="editing.instrumentForVoice !== voice.id">{{ voice.name }}</span>
                                        <select v-else v-model="voice.instrument" @blur="editing.instrumentForVoice = null" class="w-full p-1 border rounded">
                                            <option v-for="instrument in midiInstruments" :key="instrument" :value="instrument">{{ instrument }}</option>
                                        </select>
                                    </td>
                                    <template v-for="(beat, beatIndex) in voice.measures[measure.originalIndex].beats">
                                        <td class="beat" :class="{ selected: selection.measure === measure.originalIndex && selection.beat === beatIndex }">
                                            <div class="note" @click.stop="editNote(voiceIndex, measure.originalIndex, beatIndex)">
                                                <div v-if="editing.note && editing.note.v === voiceIndex && editing.note.m === measure.originalIndex && editing.note.b === beatIndex">
                                                    <select v-model="beat.note.pitch" class="p-1 border rounded text-sm w-full">
                                                        <option v-for="p in pitches" :value="p">{{ p }}</option>
                                                    </select>
                                                    <select v-model="beat.note.octave" class="p-1 border rounded text-sm w-full mt-1">
                                                        <option v-for="o in octaves" :value="o">{{ o }}</option>
                                                    </select>
                                                </div>
                                                <div v-else class="note-content">
                                                    <span>{{ beat.note.pitch }}</span>
                                                    <sup v-if="beat.note.octave > voice.defaultOctave">{{ '|'.repeat(beat.note.octave - voice.defaultOctave) }}</sup>
                                                    <sub v-if="beat.note.octave < voice.defaultOctave">{{ '|'.repeat(voice.defaultOctave - beat.note.octave) }}</sub>
                                                </div>
                                            </div>
                                        </td>
                                    </template>
                                </tr>
                                <!-- Paroles -->
                                 <tr v-for="(lyricLine, lyricIndex) in score.lyrics" :key="lyricLine.id">
                                    <td v-if="systemIndex === 0 && measureIndex === 0" class="voice-name text-sm italic" @click="toggleLyricVoiceEditor(lyricLine.id)">
                                        <div v-if="editing.lyricLineId !== lyricLine.id">Paroles {{ lyricIndex + 1 }}</div>
                                        <div v-else class="lyric-voice-editor">
                                            <div class="font-bold mb-1">Voix concern√©es:</div>
                                            <div v-for="voice in score.voices" :key="voice.id">
                                                <input type="checkbox" :id="'v'+voice.id+'l'+lyricLine.id" :value="voice.id" v-model="lyricLine.appliesToVoices">
                                                <label :for="'v'+voice.id+'l'+lyricLine.id">{{ voice.name }}</label>
                                            </div>
                                        </div>
                                    </td>
                                    <template v-for="(beat, beatIndex) in lyricLine.measures[measure.originalIndex].beats">
                                        <td class="beat">
                                            <input type="text" v-model="beat.lyric" class="lyrics-input">
                                        </td>
                                    </template>
                                </tr>
                                <!-- Contr√¥les des temps -->
                                <tr>
                                    <td v-if="systemIndex === 0 && measureIndex === 0" class="voice-name"></td>
                                    <td v-for="(beat, beatIndex) in score.voices[0].measures[measure.originalIndex].beats" class="pt-2">
                                         <button @click="divideBeatInTwo(measure.originalIndex, beatIndex)" class="beat-control-button bg-blue-500" title="Diviser ce temps en deux">√∑2</button>
                                         <button @click="deleteBeat(measure.originalIndex, beatIndex)" class="beat-control-button bg-red-500" title="Supprimer ce temps">X</button>
                                         <div class="beat-duration">{{ beat.duration }} temps</div>
                                    </td>
                                </tr>
                                <!-- Contr√¥les de Mesure -->
                                <tr>
                                    <td v-if="systemIndex === 0 && measureIndex === 0" class="voice-name"></td>
                                    <td :colspan="score.voices[0].measures[measure.originalIndex].beats.length" class="py-2">
                                        <div class="flex justify-center space-x-2">
                                            <button @click="insertMeasure(measure.originalIndex)" class="bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-2 rounded text-xs" title="Ins√©rer une mesure √† cet endroit">Ins√©rer</button>
                                            <button @click="deleteMeasure(measure.originalIndex)" class="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-2 rounded text-xs" title="Supprimer cette mesure">Supprimer</button>
                                        </div>
                                    </td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </template>
            </div>
        </main>
    </div>

    <script>
        const { createApp, reactive, watch, computed, nextTick, ref } = Vue;

        createApp({
            setup() {
                const measuresPerSystem = ref(4);
                const score = reactive({
                    meta: {
                        scoreNumber: 'No. 1', title: 'Titre de la Partition', key: 'C',
                        authors: 'Auteur(s)', subtitle: 'Sous-titre', referenceBook: 'Livre de r√©f√©rence',
                        timeSignature: '4/4', tempo: 120,
                    },
                    voices: [],
                    lyrics: [],
                });

                const pitches = ['d', 'de', 'r', 're', 'm', 'f', 'fe', 's', 'se', 'l', 'ta', 't', ' ', '-'];
                const octaves = [-3, -2, -1, 0, 1, 2, 3].map(o => 4 + o);
                const midiInstruments = ["Piano", "Marimba", "Organ", "Accordion", "Guitar", "Bass", "Violin", "Cello", "Trumpet", "Trombone", "Sax", "Clarinet", "Flute", "Recorder", "Oboe", "Synth Voice", "Orchestra Hit"];
                const tonalKeys = { 'C': 'Do', 'Db': 'Do#', 'D': 'R√©', 'Eb': 'Mib', 'E': 'Mi', 'F': 'Fa', 'Gb': 'Fa#', 'G': 'Sol', 'Ab': 'Sol#', 'A': 'La', 'Bb': 'Sib', 'B': 'Si' };
                const solfaToChromatic = { 'd':0, 'de':1, 'r':2, 're':3, 'm':4, 'f':5, 'fe':6, 's':7, 'se':8, 'l':9, 'ta':10, 't':11 };
                const chromaticToSolfa = Object.fromEntries(Object.entries(solfaToChromatic).map(a => a.reverse()));
                const keyToOffset = { 'C':0, 'Db':1, 'D':2, 'Eb':3, 'E':4, 'F':5, 'Gb':6, 'G':7, 'Ab':8, 'A':9, 'Bb':10, 'B':11 };

                const editing = reactive({ note: null, instrumentForVoice: null, lyricLineId: null });
                const selection = reactive({ measure: null, beat: null });

                // Computed property to group measures into systems
                const systems = computed(() => {
                    const systemsArray = [];
                    const measures = score.voices[0]?.measures || [];
                    for (let i = 0; i < measures.length; i += measuresPerSystem.value) {
                        systemsArray.push(measures.slice(i, i + measuresPerSystem.value).map((m, idx) => ({ ...m, originalIndex: i + idx })));
                    }
                    return systemsArray;
                });

                const createEmptyNote = (octave) => ({ pitch: ' ', octave: octave });
                const createEmptyBeat = (octave, duration = 0.25) => ({ note: createEmptyNote(octave), duration: duration, symbol: '' });
                const createEmptyMeasure = (octave) => ({ beats: [
                    createEmptyBeat(octave),
                    createEmptyBeat(octave),
                    createEmptyBeat(octave),
                    createEmptyBeat(octave)
                ]});
                const createEmptyLyricBeat = () => ({ lyric: '' });
                const createEmptyLyricMeasure = () => ({ beats: [
                    createEmptyLyricBeat(),
                    createEmptyLyricBeat(),
                    createEmptyLyricBeat(),
                    createEmptyLyricBeat()
                ]});

                const showMessage = (text, type = 'info') => {
                    const existingMessage = document.querySelector('.floating-message');
                    if (existingMessage) existingMessage.remove();

                    const message = document.createElement('div');
                    message.textContent = text;
                    message.className = 'floating-message';
                    let bgColor = '#3b82f6'; // blue
                    if (type === 'error') bgColor = '#f87171'; // red
                    if (type === 'success') bgColor = '#4ade80'; // green

                    message.style.cssText = `
                        position: fixed; top: 20px; right: 20px; background-color: ${bgColor};
                        color: white; padding: 12px 20px; border-radius: 8px; z-index: 1000;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: opacity 0.5s ease-in-out;
                    `;
                    document.body.appendChild(message);
                    setTimeout(() => {
                        message.style.opacity = '0';
                        setTimeout(() => message.remove(), 500);
                    }, 3000);
                };

                const initializeScore = () => {
                    ['Soprano', 'Alto', 'Tenor', 'Basse'].forEach((name, i) => {
                        addVoice(name, i < 2 ? 4 : 3);
                    });
                    addMeasureToAll();
                    addLyricLine();
                };
                
                const syncStructures = () => {
                    const measureCount = score.voices[0]?.measures.length || 0;
                    if (measureCount === 0) return;
                    const getMeasureBeats = (measureIndex) => score.voices[0]?.measures[measureIndex]?.beats || [];
                    
                    score.lyrics.forEach(line => {
                        while (line.measures.length < measureCount) line.measures.push(createEmptyLyricMeasure());
                        while (line.measures.length > measureCount) line.measures.pop();
                        line.measures.forEach((measure, mIdx) => {
                            const voiceBeatCount = getMeasureBeats(mIdx).length;
                            while (measure.beats.length < voiceBeatCount) measure.beats.push(createEmptyLyricBeat());
                            while (measure.beats.length > voiceBeatCount) measure.beats.pop();
                        });
                    });
                };
                
                watch(() => score.voices, syncStructures, { deep: true });

                watch(() => score.meta.key, (newKey, oldKey) => {
                    if(!oldKey) return;
                    const oldOffset = keyToOffset[oldKey];
                    const newOffset = keyToOffset[newKey];
                    const transposeInterval = newOffset - oldOffset;
                    if (transposeInterval === 0) return;

                    score.voices.forEach(voice => {
                        voice.measures.forEach(measure => {
                            measure.beats.forEach(beat => {
                                if (solfaToChromatic[beat.note.pitch] !== undefined) {
                                    let numericPitch = solfaToChromatic[beat.note.pitch];
                                    let transposedPitch = (numericPitch + transposeInterval + 12) % 12;
                                    beat.note.pitch = chromaticToSolfa[transposedPitch];
                                }
                            });
                        });
                    });
                });

                const addVoice = (name = 'Nouvelle Voix', defaultOctave = 3) => {
                    const newId = score.voices.length ? Math.max(...score.voices.map(v => v.id)) + 1 : 1;
                    const newVoice = {
                        id: newId, name: name, instrument: 'Piano', defaultOctave: defaultOctave, measures: []
                    };
                    const measureCount = score.voices[0]?.measures.length || 0;
                    for (let i = 0; i < measureCount; i++) {
                        const beatCount = score.voices[0].measures[i].beats.length;
                        newVoice.measures.push(createEmptyMeasure(newVoice.defaultOctave));
                        newVoice.measures[i].beats.splice(0, newVoice.measures[i].beats.length, ...Array.from({length: beatCount}, () => createEmptyBeat(newVoice.defaultOctave)));
                    }
                    score.voices.push(newVoice);
                    syncStructures();
                };

                const addMeasureToAll = () => {
                    score.voices.forEach(voice => {
                        voice.measures.push(createEmptyMeasure(voice.defaultOctave));
                    });
                    syncStructures();
                };
                
                const insertMeasure = (measureIndex) => {
                    score.voices.forEach(voice => {
                        voice.measures.splice(measureIndex, 0, createEmptyMeasure(voice.defaultOctave));
                    });
                    syncStructures();
                };

                const deleteMeasure = (measureIndex) => {
                    if (score.voices[0].measures.length <= 1) return showMessage("La partition doit contenir au moins une mesure.", 'error');
                    score.voices.forEach(voice => {
                        voice.measures.splice(measureIndex, 1);
                    });
                    syncStructures();
                };

                const divideBeatInTwo = (measureIndex, beatIndex) => {
                    score.voices.forEach(voice => {
                        const originalBeat = voice.measures[measureIndex].beats[beatIndex];
                        const newDuration = originalBeat.duration / 2;

                        if (newDuration < 0.125) { 
                            showMessage("Un temps ne peut pas √™tre divis√© en plus de petites dur√©es.", 'error');
                            return;
                        }
                        
                        const newBeat1 = { ...originalBeat, duration: newDuration };
                        const newBeat2 = createEmptyBeat(voice.defaultOctave, newDuration);
                        
                        voice.measures[measureIndex].beats.splice(beatIndex, 1, newBeat1, newBeat2);
                    });
                    syncStructures();
                };
                
                const deleteBeat = (measureIndex, beatIndex) => {
                    if (score.voices[0].measures[measureIndex].beats.length <= 1) {
                         deleteMeasure(measureIndex);
                    } else {
                        score.voices.forEach(voice => {
                            voice.measures[measureIndex].beats.splice(beatIndex, 1);
                        });
                        syncStructures();
                    }
                };

                const addLyricLine = () => {
                    const newLine = { 
                        id: Date.now(), 
                        appliesToVoices: score.voices.map(v => v.id),
                        measures: [] 
                    };
                    score.lyrics.push(newLine);
                    syncStructures();
                };

                const toggleLyricVoiceEditor = (lyricId) => {
                    editing.lyricLineId = editing.lyricLineId === lyricId ? null : lyricId;
                };
                
                const isBeatSelected = (mIdx, bIdx) => selection.measure === mIdx && selection.beat === bIdx;
                const editNote = (v,m,b) => { editing.note = {v,m,b}; };
                const isNoteEditing = (v,m,b) => editing.note && editing.note.v === v && editing.note.m === m && editing.note.b === b;

                const exportToJson = () => {
                    console.log(JSON.stringify(score, null, 2));
                    showMessage("La structure de la partition a √©t√© affich√©e dans la console du navigateur (F12).");
                };

                initializeScore();
                
                window.addEventListener('click', (e) => {
                    if (!e.target.closest('.note, .voice-name')) editing.note = null;
                    if (!e.target.closest('.voice-name.italic')) editing.lyricLineId = null;
                });

                return {
                    score, pitches, octaves, midiInstruments, tonalKeys, editing, selection,
                    addVoice, addMeasureToAll: insertMeasure, insertMeasure, deleteMeasure,
                    divideBeatInTwo, deleteBeat, isBeatSelected,
                    editNote, isNoteEditing, addLyricLine, toggleLyricVoiceEditor,
                    exportToJson, systems
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
